import json
import os
import time
import requests
from datetime import datetime
from bs4 import BeautifulSoup
import argparse

# --- Configurações ---
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
VULNERS_API_URL = "https://vulners.com/api/v3/search/lucene/"
CACHE_DIR = "cache"
if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)

# --- Utilitários ---
def carregar_inventario(caminho_arquivo):
    with open(caminho_arquivo, "r", encoding="utf-8") as f:
        return json.load(f)

def salvar_json(caminho, dados):
    with open(caminho, "w", encoding="utf-8") as f:
        json.dump(dados, f, indent=4, ensure_ascii=False)

def carregar_cache(nome):
    caminho = os.path.join(CACHE_DIR, f"{nome}.json")
    if os.path.exists(caminho):
        with open(caminho, "r", encoding="utf-8") as f:
            return json.load(f)
    return None

def salvar_cache(nome, dados):
    caminho = os.path.join(CACHE_DIR, f"{nome}.json")
    salvar_json(caminho, dados)

# --- NVD ---
def buscar_cve_nvd(nome, versao):
    cache_key = f"nvd_{nome}_{versao}".replace(" ", "_")
    cache = carregar_cache(cache_key)
    if cache:
        return cache

    params = {"keywordSearch": f"{nome} {versao}", "resultsPerPage": 50}
    try:
        response = requests.get(NVD_API_URL, params=params, timeout=10)
        response.raise_for_status()
        dados = response.json()
    except Exception as e:
        print(f"Erro NVD {nome} {versao}: {e}")
        return []

    cves = []
    for item in dados.get("vulnerabilities", []):
        cve_info = item.get("cve", {})
        cve_id = cve_info.get("id", "")
        descricao = cve_info.get("descriptions", [{}])[0].get("value", "")
        severity = cve_info.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {}).get("baseSeverity", "UNKNOWN")
        cves.append({"cve_id": cve_id, "descricao": descricao, "severity": severity})

    salvar_cache(cache_key, cves)
    time.sleep(1)
    return cves

# --- Vulners ---
def buscar_exploits_vulners(nome, versao):
    cache_key = f"vulners_{nome}_{versao}".replace(" ", "_")
    cache = carregar_cache(cache_key)
    if cache:
        return cache

    query = f"software:{nome} version:{versao}"
    try:
        response = requests.post(VULNERS_API_URL, json={"query": query, "size": 20}, timeout=10)
        response.raise_for_status()
        dados = response.json()
    except Exception as e:
        print(f"Erro Vulners {nome} {versao}: {e}")
        return []

    exploits = []
    for hit in dados.get("data", {}).get("search", []):
        cve_id = hit.get("id", "")
        title = hit.get("title", "")
        exploits.append({"cve_id": cve_id, "descricao": title})

    salvar_cache(cache_key, exploits)
    time.sleep(1)
    return exploits

# --- Versão mais recente automatizada ---
def obter_versao_mais_recente(nome):
    try:
        if nome.lower() == "wordpress":
            r = requests.get("https://wordpress.org/download/", timeout=10)
            soup = BeautifulSoup(r.text, "html.parser")
            version = soup.find("a", {"class": "button download-button"}).text.strip().split()[-1]
            return version
        elif nome.lower() == "drupal":
            r = requests.get("https://www.drupal.org/project/drupal/releases", timeout=10)
            soup = BeautifulSoup(r.text, "html.parser")
            version = soup.find("td", {"class": "version"}).text.strip()
            return version
        elif nome.lower() == "joomla":
            r = requests.get("https://downloads.joomla.org/latest", timeout=10)
            soup = BeautifulSoup(r.text, "html.parser")
            version = soup.find("h2").text.strip().split()[-1]
            return version
        else:
            return "Desconhecida"
    except Exception as e:
        print(f"Erro ao obter versão mais recente de {nome}: {e}")
        return "Desconhecida"

# --- Avaliação de risco ---
# def avaliar_risco(cves, exploits):
#     if any(c["severity"] == "HIGH" for c in cves) or exploits:
#         return "Alto"
#     if any(c["severity"] == "MEDIUM" for c in cves):
#         return "Médio"
#     return "Baixo"
def avaliar_risco(cves):
    if any(c["severity"] == "HIGH" for c in cves):
        return "Alto"
    if any(c["severity"] == "MEDIUM" for c in cves):
        return "Médio"
    return "Baixo"


# --- Determina alerta ---
def gerar_alerta(risco, desatualizada):
    if risco == "Alto" or desatualizada:
        return "Atualização urgente necessária"
    elif risco == "Médio":
        return "Revisar e atualizar quando possível"
    else:
        return "Sem ação imediata necessária"

# --- Análise completa ---
def analisar_aplicacoes(inventario):
    itens = []
    for app in inventario:
        nome = app.get("nome")
        url = app.get("url")
        versao = app.get("versao")
        print(f"Analisando {nome} ({versao})...")

        cves = buscar_cve_nvd(nome, versao)
        #exploits = buscar_exploits_vulners(nome, versao)
        #risco = avaliar_risco(cves, exploits)
        risco = avaliar_risco(cves)
        # versao_recomendada = obter_versao_mais_recente(nome)
        versao_recomendada = 'Não verificado'
        desatualizada = versao != versao_recomendada
        alerta = gerar_alerta(risco, desatualizada)

        # relatorio.append({
        #     "nome": nome,
        #     "url": url,
        #     "versao_atual": versao,
        #     "versao_recomendada": versao_recomendada,
        #     "desatualizada": desatualizada,
        #     "cves": cves,
        #     "exploits_ativos": exploits,
        #     "risco": risco,
        #     "alerta": alerta
        # })
        itens.append({
            "nome": nome,
            "url": url,
            "versao_atual": versao,
            "versao_recomendada": versao_recomendada,
            "desatualizada": desatualizada,
            "cves": cves,
            "exploits_ativos": 'Não avaliado',
            "risco": risco,
            "alerta": alerta
        })
    report = {
        "last_checked": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
        "report_itens": itens
    }
    return report

# --- Execução ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analisador de riscos de aplicações web")
    parser.add_argument("--input", help="Caminho do arquivo JSON de inventário", default="inventario.json")
    parser.add_argument("--output", help="Caminho do arquivo JSON de saída", default="relatorio_risco_alerta.json")

    args = parser.parse_args()

    inventario = carregar_inventario(args.input)
    relatorio = analisar_aplicacoes(inventario)
    salvar_json(args.output, relatorio)
    print("Análise completa. Relatório salvo em relatorio_risco_alerta.json")
